<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Device Checklist & SAS Panel Parser</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="manifest" href="manifest.json">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#800000">
  <style>
    /* ==============================
       CSS Variables (Theme)
       ============================== */
    :root {
      --primary-color: #800000; /* Maroon */
      --hover-color: #650000;   /* Darker Maroon */
      --text-on-primary: #ffffff;
      --background-light: #f9f9f9;
      --background-medium: #ecf0f1;
      --background-white: #ffffff;
      --text-dark: #333;
      --text-medium: #555;
      --text-light: #666;
      --border-color: #ccc;
      --border-radius-small: 3px;
      --border-radius-medium: 4px;
      --box-shadow-light: 0 1px 3px rgba(0, 0, 0, 0.1);
      --box-shadow-medium: 0 2px 5px rgba(0, 0, 0, 0.15);
      --box-shadow-heavy: 0 2px 8px rgba(0, 0, 0, 0.2);
      --highlight-bg: #fff3cd; /* Background for search term highlight */
      --highlight-text: #664d03; /* Text color for search term highlight */
      --transition-speed: 0.2s ease;
    }

    /* ==============================
       Base / Global Styles
       ============================== */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html { scroll-behavior: smooth; } /* Enable smooth scrolling */
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
      background-color: var(--background-light);
      color: var(--text-dark);
      margin-top: 80px;
      line-height: 1.5;
      padding-bottom: 60px;
    }
    h1 { text-align: center; color: #222; margin: 15px 0; }
    button { cursor: pointer; }
    button:disabled { cursor: not-allowed; opacity: 0.6; } /* General disabled style */

    /* Search term highlight style */
    .search-highlight {
        background-color: var(--highlight-bg);
        color: var(--highlight-text);
        border-radius: 2px;
        padding: 0.1em 0; /* Minimal padding */
        font-weight: 600; /* Make highlight bolder */
    }

    /* ==============================
       Fixed Top Bar & Contents
       ============================== */
    #fixedTopBar {
      position: fixed; top: 0; left: 0; width: 100%;
      background: var(--primary-color); color: var(--text-on-primary);
      z-index: 1000; border-bottom: 1px solid var(--hover-color);
      box-shadow: var(--box-shadow-heavy); padding: 10px 0;
    }
    #topBarContents {
      max-width: 800px; margin: 0 auto; display: flex; flex-wrap: wrap;
      align-items: center; justify-content: space-between; padding: 0 15px;
    }
    #deviceCount {
      font-weight: bold; font-size: 1.1em; flex: 0 1 auto;
      margin-right: 15px; margin-bottom: 5px; white-space: nowrap;
    }

    /* ==============================
       Top Bar Inputs / Buttons
       ============================== */
    #searchDevices {
      flex: 1 1 180px; max-width: 250px; padding: 7px 10px;
      margin: 0 10px 5px 0; border: 1px solid var(--border-color);
      border-radius: var(--border-radius-small); font-size: 0.95em;
      color: var(--text-dark); transition: border-color var(--transition-speed), box-shadow var(--transition-speed);
    }
    #searchDevices:focus {
      outline: none; border-color: #999;
      box-shadow: 0 0 5px rgba(128, 0, 0, 0.3);
    }
    .tripleActions {
      display: flex; flex: 1 1 auto; align-items: center;
      justify-content: flex-end; gap: 10px; margin-top: 5px;
    }
    .hideCompletedContainer { display: flex; align-items: center; margin-right: auto; }
    .hideCompletedContainer label {
      cursor: pointer; margin-left: 5px; font-size: 0.9em;
      color: var(--text-on-primary); user-select: none;
    }
    .hideCompletedContainer input {
      transform: scale(1.15); cursor: pointer; accent-color: var(--text-on-primary);
    }
    #advancedToolsBtn, #undoLastBtn {
      border: none; background: var(--background-medium); color: var(--primary-color);
      padding: 7px 14px; font-size: 0.9em; font-weight: 500;
      border-radius: var(--border-radius-medium);
      transition: background-color var(--transition-speed), transform var(--transition-speed), opacity 0.15s ease;
      white-space: nowrap;
    }
    #advancedToolsBtn:not(:disabled):hover, #undoLastBtn:not(:disabled):hover {
      background: #dde2e4; transform: translateY(-1px);
    }
    /* Keep disabled style consistent */
    #undoLastBtn:disabled { transform: none; }

    /* ==============================
       Advanced Tools Dropdown
       ============================== */
    #advancedToolsDropdown {
      position: absolute; top: calc(100% + 5px); right: 15px;
      background: var(--background-white); border: 1px solid var(--border-color);
      border-radius: var(--border-radius-medium); box-shadow: var(--box-shadow-heavy);
      width: 220px; display: none; padding: 8px; z-index: 1001;
      opacity: 0; transform: translateY(-10px);
      transition: opacity var(--transition-speed), transform var(--transition-speed);
    }
    #advancedToolsDropdown.open {
       display: block; opacity: 1; transform: translateY(0);
    }
    #advancedToolsDropdown button {
      display: block; width: 100%; margin: 4px 0; padding: 9px 12px;
      border: none; border-radius: var(--border-radius-small);
      background: var(--primary-color); color: var(--text-on-primary);
      font-size: 0.9em; text-align: left;
      transition: background-color var(--transition-speed);
    }
    #advancedToolsDropdown button:hover { background: var(--hover-color); }

    /* ==============================
       Header Info
       ============================== */
    #headerInfo {
      text-align: center; font-weight: bold; margin: 20px auto;
      padding: 15px 20px; background: var(--background-medium);
      border-radius: var(--border-radius-medium); max-width: 800px;
      box-shadow: var(--box-shadow-light); color: #444;
      font-size: 0.95em; min-height: 2em;
    }

    /* ==============================
       Upload Section
       ============================== */
    #uploadSection {
      max-width: 600px; margin: 25px auto; text-align: center;
      background: var(--background-white); border-radius: var(--border-radius-medium);
      box-shadow: var(--box-shadow-medium); padding: 25px;
    }
    #uploadSection p { margin: 12px 0 8px 0; color: var(--text-medium); font-size: 0.95em; }
    #uploadSection input[type="file"] {
      display: block; margin: 10px auto; font-size: 0.9em; color: var(--text-dark);
    }
    #uploadSection input[type="file"]::file-selector-button {
        padding: 6px 12px; margin-right: 10px; border: none;
        border-radius: var(--border-radius-small); background: var(--background-medium);
        color: var(--primary-color); cursor: pointer;
        transition: background-color var(--transition-speed);
    }
    #uploadSection input[type="file"]::file-selector-button:hover { background: #dde2e4; }
    .importExportActions {
        margin-top: 15px; display: flex; justify-content: center; gap: 10px;
    }
    #uploadSection button {
      padding: 8px 16px; border: none; border-radius: var(--border-radius-medium);
      background: var(--primary-color); color: var(--text-on-primary);
      font-size: 0.9em; font-weight: 500;
      transition: background-color var(--transition-speed), transform var(--transition-speed), opacity 0.15s ease;
    }
    #uploadSection button:not(:disabled):hover {
      background: var(--hover-color); transform: translateY(-1px);
    }
    #loading {
      text-align: center; font-style: italic; margin-top: 15px;
      color: var(--text-light); min-height: 1.5em; transition: color 0.3s ease;
    }
    #loading.error { /* Style for error messages */
        color: var(--primary-color);
        font-weight: bold;
    }

    /* ==============================
       Device List
       ============================== */
    #devicesOnPage {
      max-width: 800px; margin: 15px auto 5px auto; color: var(--text-light);
      text-align: right; font-size: 0.85em; padding: 0 10px;
    }
    #deviceList {
      max-width: 800px; margin: 0 auto 20px auto; padding: 0; list-style: none;
      position: relative; /* For empty message positioning */
      min-height: 100px; /* Ensure space for empty message */
    }
    #deviceList:empty::after { /* Empty state message */
        content: "Upload a PDF/Excel report or import a .json checklist to begin.";
        position: absolute;
        top: 20px;
        left: 0;
        width: 100%;
        text-align: center;
        color: var(--text-medium);
        font-style: italic;
        font-size: 1em;
    }
    #deviceList li {
      background: var(--background-white); margin: 8px 0; padding: 12px 15px;
      border-radius: var(--border-radius-medium); display: flex; align-items: flex-start;
      box-shadow: var(--box-shadow-light);
      transition: background-color var(--transition-speed), box-shadow var(--transition-speed);
      cursor: pointer;
    }
    #deviceList li:hover { background: #f0f0f0; box-shadow: var(--box-shadow-medium); }
    #deviceList input[type="checkbox"] {
      margin-right: 12px; margin-top: 2px; transform: scale(1.2);
      cursor: pointer; accent-color: var(--primary-color); flex-shrink: 0;
    }
    #deviceList label {
      flex-grow: 1; cursor: pointer; font-size: 0.95em; line-height: 1.4;
    }
    #deviceList label em {
      color: var(--text-medium); font-size: 0.9em; display: block; margin-top: 4px;
    }
    #deviceList label.checked { text-decoration: line-through; color: var(--text-light); }
    #deviceList label.checked em { text-decoration: none; }
    #deviceList label.checked .search-highlight { /* Adjust highlight for checked items */
        text-decoration: line-through;
        background-color: #e9ecef; /* Lighter background when checked */
        color: var(--text-light);
    }


    /* ==============================
       Back to Top Button
       ============================== */
    #backToTopBtn {
      position: fixed; bottom: 20px; right: 20px; display: none; border: none;
      background: var(--primary-color); color: var(--text-on-primary);
      padding: 10px 15px; border-radius: var(--border-radius-medium); cursor: pointer;
      box-shadow: var(--box-shadow-heavy); z-index: 999;
      transition: background-color var(--transition-speed), opacity 0.3s ease, transform 0.2s ease;
      opacity: 0.8;
    }
    #backToTopBtn:hover { background: var(--hover-color); opacity: 1; transform: scale(1.05); }

    /* ==============================
       Responsive (max-width: 600px)
       ============================== */
    @media (max-width: 600px) {
      body { margin-top: 65px; }
      #topBarContents { justify-content: center; padding: 0 10px; }
      #deviceCount { font-size: 1.15em; margin-bottom: 8px; margin-right: 0; text-align: center; width: 100%; }
      #searchDevices { flex-basis: 90%; max-width: none; margin: 0 auto 10px auto; }
      .tripleActions { flex-basis: 100%; justify-content: space-around; margin-top: 8px; }
      .hideCompletedContainer { margin-right: 0; }
      #devicesOnPage { text-align: center; }
      #advancedToolsDropdown { right: 50%; transform: translateX(50%); top: calc(100% + 5px); }
      #advancedToolsDropdown.open { transform: translateX(50%) translateY(0); }
      #uploadSection { margin: 20px 10px; padding: 20px 15px; }
      #deviceList { margin: 0 10px 20px 10px; }
      #deviceList:empty::after { font-size: 0.9em; } /* Adjust empty message size */
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.14.305/pdf.min.js" defer></script>
  <script defer>
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.14.305/pdf.worker.min.js';
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js" defer></script>
</head>
<body>

  <div id="fixedTopBar">
    <div id="topBarContents">
      <div id="deviceCount" aria-live="polite">Devices Remaining: 0</div>
      <input type="text" id="searchDevices" placeholder="Search devices..." aria-label="Search devices">
      <div class="tripleActions">
        <div class="hideCompletedContainer">
          <input type="checkbox" id="toggleHideCompleted" />
          <label for="toggleHideCompleted">Hide Completed</label>
        </div>
        <button id="advancedToolsBtn" aria-haspopup="true" aria-expanded="false">Advanced Tools</button>
        <button id="undoLastBtn" disabled>Undo Last</button> </div>
    </div>
    <div id="advancedToolsDropdown">
      <button id="markAllBtn">Mark All Completed</button>
      <button id="clearAllBtn">Clear All Unchecked</button>
      <button id="clearSessionBtn">Clear Session & List</button>
    </div>
  </div>

  <h1>Device Checklist</h1>
  <div id="headerInfo"></div>

  <div id="uploadSection">
    <p>Select PDF device report(s):</p>
    <input type="file" id="pdfInput" accept="application/pdf" multiple data-button-id="pdfUploadBtn">
    <p>Select Excel device report(s):</p>
    <input type="file" id="excelInput" accept=".xlsx, .xls" multiple data-button-id="excelUploadBtn">
     <p>Import / Export Device Checklist:</p>
    <div class="importExportActions">
        <button id="exportFileBtn">Export to File</button>
        <button id="importFileBtn">Import from File</button>
    </div>
  </div>

  <div id="loading" role="status" aria-live="polite"></div>

  <div id="devicesOnPage">(Displaying: 0)</div>

  <ul id="deviceList"></ul> <button id="backToTopBtn" title="Scroll back to top">Back to Top</button>

  <script defer>
    "use strict";

    // === Constants ===
    const SESSION_STORAGE_KEY = 'deviceChecklist';
    const SEARCH_DEBOUNCE_DELAY = 300; // milliseconds

    document.addEventListener('DOMContentLoaded', () => {

      // === Global State Variables ===
      let deviceChecklistData = { header: "", devices: [] };
      let undoStack = [];
      let hideCompleted = false;
      let searchDebounceTimeout = null; // For debouncing search input

      // === DOM Element References ===
      const deviceCountEl = document.getElementById("deviceCount");
      const searchInputEl = document.getElementById("searchDevices");
      const toggleHideCompletedEl = document.getElementById("toggleHideCompleted");
      const advancedToolsBtnEl = document.getElementById("advancedToolsBtn");
      const undoLastBtnEl = document.getElementById("undoLastBtn");
      const advancedToolsDropdownEl = document.getElementById("advancedToolsDropdown");
      const markAllBtnEl = document.getElementById("markAllBtn");
      const clearAllBtnEl = document.getElementById("clearAllBtn");
      const clearSessionBtnEl = document.getElementById("clearSessionBtn");
      const headerInfoEl = document.getElementById("headerInfo");
      const pdfInputEl = document.getElementById("pdfInput");
      const excelInputEl = document.getElementById("excelInput");
      const exportFileBtnEl = document.getElementById("exportFileBtn");
      const importFileBtnEl = document.getElementById("importFileBtn");
      const loadingEl = document.getElementById("loading");
      const devicesOnPageEl = document.getElementById("devicesOnPage");
      const deviceListEl = document.getElementById("deviceList");
      const backToTopBtnEl = document.getElementById("backToTopBtn");
      const fileImportInputEl = document.createElement('input');
      fileImportInputEl.type = 'file';
      fileImportInputEl.accept = '.json';
      fileImportInputEl.style.display = 'none';

      // === Utility Functions ===
      /**
       * Debounce function to limit how often a function is called.
       * @param {Function} func The function to debounce.
       * @param {number} delay Debounce delay in milliseconds.
       */
      function debounce(func, delay) {
          return function(...args) {
              clearTimeout(searchDebounceTimeout);
              searchDebounceTimeout = setTimeout(() => {
                  func.apply(this, args);
              }, delay);
          };
      }

      /**
        * Escapes special characters in a string for use in a RegExp.
        * @param {string} string - The input string.
        * @returns {string} The escaped string.
        */
      function escapeRegExp(string) {
          return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
      }


      // === Session Management Functions ===
      function saveSession() {
        try {
          localStorage.setItem(SESSION_STORAGE_KEY, JSON.stringify(deviceChecklistData));
          updateUndoButtonState();
        } catch (e) {
          console.error("Error saving session:", e);
          setLoadingMessage("Could not save session. Storage might be full.", true);
        }
      }
      function loadSession() {
        const data = localStorage.getItem(SESSION_STORAGE_KEY);
        if (data) {
          try {
            deviceChecklistData = JSON.parse(data);
            if (!deviceChecklistData.header) deviceChecklistData.header = "";
            if (!Array.isArray(deviceChecklistData.devices)) deviceChecklistData.devices = [];
            // Ensure 'checked' property exists
            deviceChecklistData.devices = deviceChecklistData.devices.map(d => ({ ...d, checked: d.checked || false }));
            return true;
          } catch (e) {
            console.error("Error parsing session data:", e);
            localStorage.removeItem(SESSION_STORAGE_KEY);
            return false;
          }
        }
        return false;
      }
      function clearSession() {
        localStorage.removeItem(SESSION_STORAGE_KEY);
        deviceChecklistData = { header: "", devices: [] };
        undoStack = [];
        updateUndoButtonState();
        pdfInputEl.value = '';
        excelInputEl.value = '';
        searchInputEl.value = ''; // Clear search input as well
      }

      // === SAS Panel Parsing Functions (CORE LOGIC - UNCHANGED) ===
      function extractDevicesFromSASPanelText(text) {
         // --- CORE SAS PARSING LOGIC - UNCHANGED ---
         // (Same implementation as provided in the previous response)
         let devices = [];
         const regexSerial = /(?:Device\s+)?(\d+):?\s+([\s\S]*?)\s+(\d{10})(?=\s+(?:Device\s+)?\d+|\s*$)/gi;
         let match;
         while ((match = regexSerial.exec(text)) !== null) {
           if (!devices.some(d => d.raw === match[0].trim())) {
               devices.push({ deviceNumber: match[1].trim(), description: match[2].trim(), serialNumber: match[3].trim(), raw: match[0].trim(), checked: false });
           }
         }
         const lines = text.split(/\r?\n/);
         const regexAnnunciator = /^(LCD\s+C\s+0\s+OREGON\s+LIBRARY\s+FIRE\s+PANEL\s+NORMAL)\s*(\d{1,2})$/i;
         lines.forEach(line => {
           line = line.trim(); const m = regexAnnunciator.exec(line);
           if (m && !devices.some(d => d.raw === line)) {
             devices.push({ deviceNumber: m[2].trim(), description: m[1].trim(), serialNumber: "", raw: line, checked: false });
           }
         });
         const regexNAC = /^(0?\d{1,2})\s+Genesis\s+Audible\s+Visible\s+Silence\s+B\s+NAC\s+(\d+)$/i;
         lines.forEach(line => {
           line = line.trim(); const m = regexNAC.exec(line);
           if (m && !devices.some(d => d.raw === line)) {
             devices.push({ deviceNumber: m[1].trim(), description: `Genesis Audible Visible Silence B NAC ${m[2].trim()}`, serialNumber: "", raw: line, checked: false });
           }
         });
         const regexAdditional = /^(?:Device\s*-\s*)?(\d{1,2})\s+(.+)$/i;
         lines.forEach(line => {
           line = line.trim(); if (!line) return;
           if (/\d{10}/.test(line)) return; if (/hours|minutes|Serial:|^Off$/i.test(line)) return;
           const m = regexAdditional.exec(line);
           if (m) {
             const devNum = m[1].trim(); const desc = m[2].trim(); if (/off/i.test(desc)) return;
             if (!devices.some(d => d.raw === line)) {
               devices.push({ deviceNumber: devNum, description: desc, serialNumber: "", raw: line, checked: false });
             }
           }
         });
         const noSerialDevicesCount = devices.filter(d => !d.serialNumber).length;
         if (noSerialDevicesCount < 5) {
           const finalSectionMatch = text.match(/Page:\s*\d+\s*Oregon_Library[\s\S]*$/i);
           if (finalSectionMatch) {
             const finalSectionText = finalSectionMatch[0]; const finalLines = finalSectionText.split(/\r?\n/);
             finalLines.forEach(line => {
                line = line.trim(); const mAnnun = regexAnnunciator.exec(line);
                if (mAnnun && !devices.some(d => d.description === mAnnun[1].trim())) { devices.push({ deviceNumber: mAnnun[2].trim(), description: mAnnun[1].trim(), serialNumber: "", raw: line, checked: false }); }
             });
             finalLines.forEach(line => {
                 line = line.trim(); const mNAC = regexNAC.exec(line); const nacDesc = `Genesis Audible Visible Silence B NAC ${mNAC ? mNAC[2].trim() : ''}`;
                  if (mNAC && !devices.some(d => d.description === nacDesc)) { devices.push({ deviceNumber: mNAC[1].trim(), description: nacDesc, serialNumber: "", raw: line, checked: false }); }
             });
           }
         }
         const uniqueDevicesMap = new Map();
         devices.forEach(device => { const key = device.serialNumber ? `${device.description}_${device.serialNumber}` : device.raw; if (!uniqueDevicesMap.has(key)) { uniqueDevicesMap.set(key, device); } });
         return Array.from(uniqueDevicesMap.values());
         // --- END OF UNCHANGED SAS LOGIC ---
      }
      function cleanDeviceDescription(desc) {
          // --- CORE CLEANING LOGIC - UNCHANGED ---
          // Removes "Device X:" prefix and tries to find the start of the real description using keywords.
          let cleanedDesc = desc.replace(/^Device\s+\d+:?\s*/i, '');
          // Keywords hint at the start of the meaningful part of the description.
          // Order might matter slightly if multiple keywords appear early.
          const keywords = ["Smoke", "Supervisory", "Heat", "Supv", "Relay", "Pull", "Monitor", "Genesis", "Water", "Auto", "Duct", "LCD", "NAC"];
          let earliestIndex = -1;
          keywords.forEach(keyword => {
              const regex = new RegExp(`\\b${keyword}\\b`, 'i');
              const match = cleanedDesc.match(regex);
              if (match !== null) {
                  const index = match.index;
                  if (earliestIndex === -1 || index < earliestIndex) { earliestIndex = index; }
              }
          });
          if (earliestIndex !== -1) { return cleanedDesc.substring(earliestIndex).trim(); }
          return cleanedDesc.trim();
          // --- END OF UNCHANGED CLEANING LOGIC ---
      }

      // === General Extraction Function (CORE LOGIC - UNCHANGED) ===
      function extractHeaderAndDevices(text) {
        // --- CORE EXTRACTION LOGIC - UNCHANGED ---
        text = text.replace(/Page \d+\s*of\s*\d+/gi, '');
        if (text.toLowerCase().includes("sas panel configuration") || text.toLowerCase().includes("oregon library fire panel")) {
            const devices = extractDevicesFromSASPanelText(text);
            const headerMatch = text.match(/Project:\s*(.*)\n/i) || text.match(/Location:\s*(.*)\n/i);
            const header = headerMatch ? headerMatch[1].trim() : "SAS Panel Configuration";
            return { header, devices };
        }
        const lines = text.split('\n').map(line => line.trim()).filter(line => line.length > 0);
        let header = "";
        let devices = [];
        if (lines.length >= 3 && lines[0].startsWith("Project")) {
            header = lines[0] + " | " + lines[1] + " | " + lines[2]; lines.splice(0, 3);
        } else if (lines.length > 0 && lines[0].includes("Version :") && lines[0].includes("Device Barcode Label")) {
            header = lines[0]; lines.shift();
        }
        if (!header && lines.length > 0) { header = lines[0]; lines.splice(0, 1); }
        const serialRegex = /\b\d{3}:\d{3}:\d{4}\b/;
        let currentDeviceLines = [];
        const rawDeviceTexts = [];
        for (const line of lines) {
            currentDeviceLines.push(line);
            if (serialRegex.test(line)) {
                rawDeviceTexts.push(currentDeviceLines.join(" ")); currentDeviceLines = [];
            }
        }
        if (currentDeviceLines.length > 0) { rawDeviceTexts.push(currentDeviceLines.join(" ")); }
        devices = rawDeviceTexts
            .map(txt => txt.trim()).filter(txt => txt.length > 5)
            .map(txt => ({
                text: txt,
                deviceNumber: txt.match(/^(\d+)\b/)?.[1] || "",
                description: cleanDeviceDescription(txt.replace(/^(\d+)\b\s*/, '')),
                serialNumber: txt.match(/(\d{3}:\d{3}:\d{4})\b/)?.[1] || "",
                raw: txt, checked: false
            }));
        return { header, devices };
        // --- END OF UNCHANGED EXTRACTION LOGIC ---
      }

      // === UI Display Functions ===
      function updateDeviceCount() {
        const remaining = deviceChecklistData.devices.filter(d => !d.checked).length;
        const total = deviceChecklistData.devices.length;
        // Text content updated, aria-live will handle announcement
        deviceCountEl.textContent = `Remaining: ${remaining} / ${total}`;
      }
      function updateUndoButtonState() {
        undoLastBtnEl.disabled = undoStack.length === 0;
      }
      function displayHeader(header) {
        headerInfoEl.textContent = header || "No project information loaded.";
      }

      /**
       * Sets the loading message and optionally styles it as an error.
       * @param {string} message The message to display.
       * @param {boolean} [isError=false] If true, apply error styling.
       */
       function setLoadingMessage(message, isError = false) {
            loadingEl.textContent = message;
            if (isError) {
                loadingEl.classList.add('error');
            } else {
                loadingEl.classList.remove('error');
            }
       }

      /**
       * Renders the list of devices. Includes filtering, empty state, and search highlighting.
       */
      function displayDevices() { // Removed 'devices' param, always uses global
        const devices = deviceChecklistData.devices;
        const searchTerm = searchInputEl.value.trim().toLowerCase();
        const fragment = document.createDocumentFragment();

        const filteredDevices = devices
          .map((device, index) => ({ device, originalIndex: index }))
          .filter(({ device }) => {
            const textToSearch = (device.description + " " + (device.serialNumber || "") + " " + (device.deviceNumber || "") + " " + (device.text || "")).toLowerCase();
            const matchesSearch = !searchTerm || textToSearch.includes(searchTerm);
            const isVisible = !(hideCompleted && device.checked);
            return matchesSearch && isVisible;
          });

        devicesOnPageEl.textContent = `(Displaying: ${filteredDevices.length})`;
        deviceListEl.innerHTML = ""; // Clear previous list

        // Setup regex for highlighting only if there's a search term
        let highlightRegex = null;
        if (searchTerm) {
            // Escape special characters in search term for safe regex use
            const escapedSearchTerm = escapeRegExp(searchTerm);
            highlightRegex = new RegExp(`(${escapedSearchTerm})`, 'gi'); // 'g' for global, 'i' for case-insensitive
        }

        filteredDevices.forEach(({ device, originalIndex }) => {
          const li = document.createElement("li");
          li.setAttribute("role", "listitem");

          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.id = `device-${originalIndex}`;
          checkbox.checked = device.checked;
          checkbox.dataset.index = originalIndex;

          const label = document.createElement("label");
          label.htmlFor = `device-${originalIndex}`;
          if(device.checked) label.classList.add('checked');

          let labelHTML = "";
          if (device.description) {
            const cleanedDesc = cleanDeviceDescription(device.description || "No Description");
            labelHTML = `${cleanedDesc}`;
            if (device.serialNumber) labelHTML += `<br><em>Serial: ${device.serialNumber}</em>`;
            else if (device.deviceNumber) labelHTML += `<br><em>Dev #: ${device.deviceNumber}</em>`;
          } else {
            labelHTML = device.text || "Invalid device data";
          }

          // Apply highlighting if needed
          if (highlightRegex && labelHTML) {
                // IMPORTANT: Replace within the text content, preserving HTML tags (<br>, <em>)
                // This is a simplified approach; complex HTML needs more robust parsing.
                labelHTML = labelHTML.replace(highlightRegex, `<span class="search-highlight">$1</span>`);
          }

          label.innerHTML = labelHTML;

          // --- Checkbox Change Listener (CORE LOGIC - UNCHANGED) ---
          checkbox.addEventListener("change", (e) => {
            const index = parseInt(e.target.dataset.index, 10);
            const currentDevice = deviceChecklistData.devices[index];
            if (!currentDevice) return; // Safety check

            const oldValue = currentDevice.checked;
            const newValue = e.target.checked;

            undoStack.push({ index, oldValue, newValue });
            currentDevice.checked = newValue;

            saveSession();
            updateDeviceCount();
            // Update label style directly
            if (newValue) label.classList.add('checked');
            else label.classList.remove('checked');

            // Re-filter if hiding completed items
            if (hideCompleted) displayDevices(); // Re-render the whole list if hiding
          });

          li.appendChild(checkbox);
          li.appendChild(label);

          // Click on li toggles checkbox
          li.addEventListener('click', (e) => {
             if (e.target !== checkbox && e.target !== label && !label.contains(e.target)) { // Check if click wasn't on label content either
                 checkbox.checked = !checkbox.checked;
                 checkbox.dispatchEvent(new Event('change'));
             }
          });

          fragment.appendChild(li);
        });

        deviceListEl.appendChild(fragment); // Append all items at once
        updateDeviceCount();
        updateUndoButtonState();
      }
       // Debounced version of displayDevices for search input
      const debouncedDisplayDevices = debounce(displayDevices, SEARCH_DEBOUNCE_DELAY);


      // === File Parsing Functions (CORE PDF/EXCEL LOGIC - UNCHANGED) ===
      function parsePDF(file) {
        return new Promise((resolve, reject) => {
          const fileReader = new FileReader();
          fileReader.onload = function() {
            const typedarray = new Uint8Array(this.result);
            setLoadingMessage(`Parsing PDF: ${file.name}...`); // Update status
            pdfjsLib.getDocument(typedarray).promise.then(pdf => {
              const pagePromises = Array.from({ length: pdf.numPages }, (_, i) =>
                 pdf.getPage(i + 1).then(page => page.getTextContent())
              );
              Promise.all(pagePromises).then(pageContents => {
                let fullText = pageContents.map(content => content?.items?.map(item => item?.str || '').join("\n") || '').join("\n");
                 setLoadingMessage(`Extracting devices from ${file.name}...`); // Update status
                 try {
                    const extractedData = extractHeaderAndDevices(fullText); // CORE CALL
                    resolve(extractedData);
                 } catch (extractError) { reject(`Extraction failed: ${extractError.message}`); }
              }).catch(reject);
            }).catch(reject);
          };
          fileReader.onerror = () => reject(`Failed to read file: ${file.name}`);
          fileReader.readAsArrayBuffer(file);
        });
      }
      function parseExcel(file) {
         return new Promise((resolve, reject) => {
          const fileReader = new FileReader();
          fileReader.onload = function(e) {
            try {
              setLoadingMessage(`Parsing Excel: ${file.name}...`); // Update status
              const data = new Uint8Array(e.target.result);
              const workbook = XLSX.read(data, { type: 'array' });
              const worksheet = workbook.Sheets[workbook.SheetNames[0]];
              const devices = []; let row = 7;
              while (true) {
                const cellB = worksheet["B" + row]; if (!cellB || !cellB.v) break;
                let deviceText = ""; ["B", "C", "D", "E", "F", "G"].forEach(col => { const cell = worksheet[col + row]; if (cell?.v) deviceText += cell.v + " "; });
                 if (deviceText.trim()) { // Only add if row has content
                    devices.push({
                       text: deviceText.trim(),
                       deviceNumber: deviceText.match(/^(\d+)\b/)?.[1] || "",
                       description: cleanDeviceDescription(deviceText.replace(/^(\d+)\b\s*/, '')),
                       serialNumber: "", raw: deviceText.trim(), checked: false
                    });
                 }
                row++;
              }
               setLoadingMessage(`Extracted devices from ${file.name}...`); // Update status
              resolve({ header: `Excel Data: ${file.name}`, devices }); // CORE RETURN
            } catch (excelError) { reject(`Excel parsing failed: ${excelError.message}`); }
          };
          fileReader.onerror = () => reject(`Failed to read file: ${file.name}`);
          fileReader.readAsArrayBuffer(file);
         });
      }
       /**
        * Handles the processing of uploaded files (PDF or Excel). Includes button disabling.
        */
       async function handleFileUpload(files, parserFn, fileTypeDesc) {
           if (!files || files.length === 0) { alert(`Please select at least one valid ${fileTypeDesc} file.`); return; }

           // Disable buttons during processing
           pdfInputEl.disabled = true;
           excelInputEl.disabled = true;
           importFileBtnEl.disabled = true;
           setLoadingMessage(`Processing ${files.length} ${fileTypeDesc} file(s)...`);

           const parsePromises = Array.from(files).map(file =>
               parserFn(file).catch(err => ({ error: true, message: err, fileName: file.name }))
           );

           const results = await Promise.all(parsePromises);
           let newDevicesAdded = 0;
           let errorsEncountered = [];
           let firstNewHeader = ""; // Store the first encountered header

           setLoadingMessage("Merging data..."); // Update status

           results.forEach(result => {
               if (result.error) {
                   errorsEncountered.push(`Failed: ${result.fileName} (${result.message})`);
               } else if (result?.devices) {
                    if (!firstNewHeader && result.header) firstNewHeader = result.header; // Capture first header

                   const currentDeviceKeys = new Set(deviceChecklistData.devices.map(d => d.serialNumber ? `${d.description}_${d.serialNumber}` : d.raw));
                   result.devices.forEach(newDevice => {
                       const key = newDevice.serialNumber ? `${newDevice.description}_${newDevice.serialNumber}` : newDevice.raw;
                       if (!currentDeviceKeys.has(key)) {
                           newDevice.checked = newDevice.checked || false; // Ensure checked exists
                           deviceChecklistData.devices.push(newDevice);
                           currentDeviceKeys.add(key);
                           newDevicesAdded++;
                       }
                   });
               }
           });

           // Update header only if the current one is empty or default, and a new one was found
           if ((!deviceChecklistData.header || deviceChecklistData.header === "No project information loaded.") && firstNewHeader) {
                deviceChecklistData.header = firstNewHeader;
           }


           if (newDevicesAdded > 0) {
               saveSession();
               displayHeader(deviceChecklistData.header);
               displayDevices();
               setLoadingMessage(`Successfully added ${newDevicesAdded} unique devices.`);
           } else if (errorsEncountered.length === 0) {
               setLoadingMessage("No new unique devices found in the selected file(s).");
           }

           if (errorsEncountered.length > 0) {
               alert("Some files could not be processed:\n- " + errorsEncountered.join("\n- "));
               setLoadingMessage("Error processing one or more files.", true); // Show error state
           }

           // Clear input values *after* processing
           if (parserFn === parsePDF) pdfInputEl.value = '';
           if (parserFn === parseExcel) excelInputEl.value = '';

           // Re-enable buttons
           pdfInputEl.disabled = false;
           excelInputEl.disabled = false;
           importFileBtnEl.disabled = false;

           // Clear success/info message after a delay
           setTimeout(() => { if (!loadingEl.classList.contains('error')) setLoadingMessage(""); }, 4000);
       }

      // === Import/Export Functions ===
      function exportListToFile() {
         if (!deviceChecklistData?.devices?.length) { alert("No device data to export."); return; }
         try {
            const dataStr = JSON.stringify(deviceChecklistData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            const filenameBase = (deviceChecklistData.header || 'device-checklist').replace(/[^a-z0-9]/gi, '_').toLowerCase();
            const dateStr = new Date().toISOString().slice(0, 10);
            link.download = `${filenameBase}_${dateStr}.json`;
            document.body.appendChild(link); link.click(); document.body.removeChild(link);
            URL.revokeObjectURL(url);
         } catch (e) { setLoadingMessage("Export failed.", true); }
      }
      fileImportInputEl.addEventListener('change', (e) => {
         const file = e.target.files[0];
         if (!file) return;
         if (!file.name.toLowerCase().endsWith('.json') || file.type !== 'application/json') {
            alert("Please select a valid .json file."); fileImportInputEl.value = ''; return;
         }

         pdfInputEl.disabled = true; excelInputEl.disabled = true; importFileBtnEl.disabled = true; // Disable buttons
         setLoadingMessage(`Importing ${file.name}...`);

         const reader = new FileReader();
         reader.onload = (evt) => {
            try {
               const importedData = JSON.parse(evt.target.result);
               if (typeof importedData !== 'object' || !importedData || !Array.isArray(importedData.devices)) {
                  throw new Error("Invalid JSON structure.");
               }
                if (!confirm(`Replace current checklist (${deviceChecklistData.devices.length} devices) with data from "${file.name}"?`)) {
                   fileImportInputEl.value = ''; setLoadingMessage("");
                   pdfInputEl.disabled = false; excelInputEl.disabled = false; importFileBtnEl.disabled = false; // Re-enable
                   return;
                }
               deviceChecklistData = importedData;
               deviceChecklistData.devices = deviceChecklistData.devices.map(d => ({ ...d, checked: d.checked || false }));
               undoStack = [];
               saveSession();
               displayHeader(deviceChecklistData.header);
               displayDevices();
               setLoadingMessage("Checklist imported successfully!");
            } catch (err) {
               setLoadingMessage(`Import failed: ${err.message}`, true);
            } finally {
               fileImportInputEl.value = '';
               setTimeout(() => { if (!loadingEl.classList.contains('error')) setLoadingMessage(""); }, 4000);
               pdfInputEl.disabled = false; excelInputEl.disabled = false; importFileBtnEl.disabled = false; // Re-enable
            }
         };
         reader.onerror = () => {
            setLoadingMessage("Failed to read the selected file.", true);
            fileImportInputEl.value = '';
            pdfInputEl.disabled = false; excelInputEl.disabled = false; importFileBtnEl.disabled = false; // Re-enable
         };
         reader.readAsText(file);
      });

      // === Event Listeners Setup ===
      undoLastBtnEl.addEventListener("click", () => {
         if (undoStack.length === 0) return;
         const lastAction = undoStack.pop();
         if (deviceChecklistData.devices[lastAction.index]) {
            deviceChecklistData.devices[lastAction.index].checked = lastAction.oldValue;
         }
         saveSession();
         displayDevices(); // Re-render
      });

      advancedToolsBtnEl.addEventListener('click', (e) => {
         e.stopPropagation();
         const isOpen = advancedToolsDropdownEl.classList.toggle('open');
         advancedToolsBtnEl.setAttribute('aria-expanded', isOpen.toString());
         if (!isOpen) advancedToolsBtnEl.focus(); // Return focus when closing
      });

      // Close dropdown with Escape key
      advancedToolsDropdownEl.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') {
              advancedToolsDropdownEl.classList.remove('open');
              advancedToolsBtnEl.setAttribute('aria-expanded', 'false');
              advancedToolsBtnEl.focus(); // Return focus
          }
      });


      markAllBtnEl.addEventListener("click", () => {
         const changedIndices = [];
         deviceChecklistData.devices.forEach((device, index) => {
            if (!device.checked) {
               undoStack.push({ index, oldValue: false, newValue: true });
               device.checked = true;
               changedIndices.push(index);
            }
         });
         if(changedIndices.length > 0) { saveSession(); displayDevices(); }
         advancedToolsDropdownEl.classList.remove('open'); advancedToolsBtnEl.setAttribute('aria-expanded', 'false'); advancedToolsBtnEl.focus();
      });

      clearAllBtnEl.addEventListener("click", () => {
         const changedIndices = [];
         deviceChecklistData.devices.forEach((device, index) => {
            if (device.checked) {
               undoStack.push({ index, oldValue: true, newValue: false });
               device.checked = false;
               changedIndices.push(index);
            }
         });
         if(changedIndices.length > 0) { saveSession(); displayDevices(); }
         advancedToolsDropdownEl.classList.remove('open'); advancedToolsBtnEl.setAttribute('aria-expanded', 'false'); advancedToolsBtnEl.focus();
      });

      clearSessionBtnEl.addEventListener("click", () => {
         // More specific confirmation message
         if (confirm(`Clear all ${deviceChecklistData.devices.length} devices and project info? This cannot be undone.`)) {
            clearSession();
            displayHeader("");
            displayDevices(); // Will show empty state
         }
         advancedToolsDropdownEl.classList.remove('open'); advancedToolsBtnEl.setAttribute('aria-expanded', 'false'); advancedToolsBtnEl.focus();
      });

      toggleHideCompletedEl.addEventListener("change", (e) => {
         hideCompleted = e.target.checked;
         displayDevices();
      });

      // Use debounced display for search input
      searchInputEl.addEventListener("input", debouncedDisplayDevices);

      pdfInputEl.addEventListener("change", (e) => handleFileUpload(e.target.files, parsePDF, "PDF"));
      excelInputEl.addEventListener("change", (e) => handleFileUpload(e.target.files, parseExcel, "Excel"));
      exportFileBtnEl.addEventListener("click", exportListToFile);
      importFileBtnEl.addEventListener("click", () => { fileImportInputEl.click(); });

      window.addEventListener("scroll", () => {
         backToTopBtnEl.style.display = (document.documentElement.scrollTop > 400 || document.body.scrollTop > 400) ? "block" : "none";
      });
      backToTopBtnEl.addEventListener("click", () => { window.scrollTo({ top: 0 /* behavior: smooth defined in CSS */ }); });

      window.addEventListener('click', (e) => {
         if (!advancedToolsDropdownEl.contains(e.target) && e.target !== advancedToolsBtnEl && advancedToolsDropdownEl.classList.contains('open')) {
            advancedToolsDropdownEl.classList.remove('open');
            advancedToolsBtnEl.setAttribute('aria-expanded', 'false');
            // Optionally return focus: advancedToolsBtnEl.focus(); (Consider UX implications)
         }
      });

      // === Initial Load ===
      if (loadSession()) {
         console.log("Session loaded.");
         displayHeader(deviceChecklistData.header);
         // Initial display happens here
      } else {
         console.log("No session found.");
         // Initial display needed even if no session
      }
      // Always display devices on initial load (handles empty/loaded state)
      displayDevices();


      // === Service Worker Registration (PWA - UNCHANGED as requested) ===
      if ('serviceWorker' in navigator) {
         window.addEventListener('load', () => { // Ensure SW registration happens after page load
            navigator.serviceWorker.register('./serviceworker.js') // Use relative path
               .then(reg => console.log('ServiceWorker registered. Scope:', reg.scope))
               .catch(err => console.error('ServiceWorker registration failed:', err));
         });
      }

    }); // End DOMContentLoaded listener
  </script>
</body>
</html>
  </script>
</body>
</html>
