<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Device Checklist</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- PWA Manifest -->
  <link rel="manifest" href="manifest.json">
  <!-- iOS PWA Support -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#333">

  <!-- Simple styling -->
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background: #f2f2f2;
      color: #333;
    }
    h1, h2 {
      text-align: center;
    }
    #headerInfo {
      text-align: center;
      font-weight: bold;
      margin: 20px auto;
      padding: 10px;
      background: #e0e0e0;
      border-radius: 4px;
      max-width: 800px;
    }
    #uploadSection, #controls {
      max-width: 600px;
      margin: 20px auto;
      text-align: center;
    }
    #deviceList {
      max-width: 800px;
      margin: 20px auto;
      padding: 0;
      list-style: none;
    }
    #deviceList li {
      background: #fff;
      margin: 8px 0;
      padding: 10px;
      border-radius: 4px;
      display: flex;
      align-items: center;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    #deviceList input[type="checkbox"] {
      margin-right: 10px;
    }
    #loading {
      text-align: center;
      font-style: italic;
    }
    /* Controls styling */
    #controls input[type="text"] {
      padding: 5px;
      width: 200px;
      margin-right: 10px;
    }
    #controls button {
      padding: 5px 10px;
      margin: 5px;
    }
    #controls label {
      margin-left: 20px;
      font-size: 0.9em;
    }
    /* Device count styling */
    #deviceCount {
      text-align: center;
      font-size: 1.1em;
      margin-bottom: 10px;
    }
    /* Order (countdown) styling */
    .orderCounter {
      font-size: 0.8em;
      margin-right: 5px;
      color: #555;
      width: 50px;
      text-align: right;
    }
  </style>

  <!-- Include PDF.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.14.305/pdf.min.js"></script>
  <!-- Set up PDF.js worker -->
  <script>
    "use strict";
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.14.305/pdf.worker.min.js';
  </script>
  <!-- Include SheetJS (xlsx) from CDN for Excel parsing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
</head>
<body>
  <h1>Device Checklist</h1>

  <!-- Header info display -->
  <div id="headerInfo" role="heading" aria-level="2"></div>

  <div id="uploadSection">
    <p>Select one or more PDF files containing device records:</p>
    <!-- PDF file input -->
    <input type="file" id="pdfInput" accept="application/pdf" multiple aria-label="Upload PDF files containing device records">
    
    <!-- New Excel file input -->
    <p>Select one or more Excel files containing device records:</p>
    <input type="file" id="excelInput" accept=".xlsx, .xls" multiple aria-label="Upload Excel files containing device records">
    
    <!-- Always-visible Export/Import for sharing device checklist -->
    <p>Import / Export Device Checklist:</p>
    <button id="exportFileBtn" aria-label="Export the checklist as a JSON file">Export to File</button>
    <button id="importFileBtn" aria-label="Import a checklist JSON file">Import from File</button>
  </div>

  <div id="loading" aria-live="polite"></div>
  
  <!-- Controls: search, mark/clear all, clear session, crossout, counter toggle, accidental touch -->
  <div id="controls" style="display:none;">
    <input
      type="text"
      id="searchDevices"
      placeholder="Search devices..."
      aria-label="Search devices"
    >
    <button id="markAllBtn" aria-label="Mark all devices as completed">Mark All as Completed</button>
    <button id="clearAllBtn" aria-label="Clear all device checkboxes">Clear All</button>
    <button id="clearSessionBtn" aria-label="Clear saved session and reset data">Clear Saved Session</button>
    <br>
    <label>
      <input type="checkbox" id="toggleCrossout">
      Enable Crossout
    </label>
    <label>
      <input type="checkbox" id="toggleCounter">
      Display Countdown
    </label>
    <label title="Prevent unchecking of an already checked item.">
      <input type="checkbox" id="toggleAccidentalTouch">
      Accidental Touch
    </label>
  </div>

  <h2>Device Checklist</h2>
  <!-- Device count display -->
  <div id="deviceCount"></div>
  
  <ul id="deviceList" role="list"></ul>

  <!-- Main Script -->
  <script>
    "use strict";

    // Global data structure for header and devices with their checked states.
    // Each device object: { text: string, checked: boolean }
    let deviceChecklistData = {
      header: "",
      devices: []
    };

    // Global flags
    let crossoutEnabled = false;
    let counterEnabled = false;
    let accidentalTouchEnabled = false;

    /**
     * Save the current checklist data to localStorage.
     */
    function saveSession() {
      localStorage.setItem("deviceChecklist", JSON.stringify(deviceChecklistData));
    }

    /**
     * Load checklist data from localStorage, if available.
     * @returns {boolean} true if session data was loaded, false otherwise
     */
    function loadSession() {
      const data = localStorage.getItem("deviceChecklist");
      if (data) {
        deviceChecklistData = JSON.parse(data);
        return true;
      }
      return false;
    }

    /**
     * Clear the saved session entirely.
     */
    function clearSession() {
      localStorage.removeItem("deviceChecklist");
      deviceChecklistData = { header: "", devices: [] };
    }

    /**
     * Extract header and device records from raw PDF text.
     * @param {string} text - The extracted raw text from the PDF
     * @returns {object} - An object containing the header string and devices array
     */
    function extractHeaderAndDevices(text) {
      // Remove footer/header patterns like "Page X of Y"
      text = text.replace(/Page \d+\s*of\s*\d+/gi, '');

      // Split text into non-empty, trimmed lines.
      let lines = text
        .split('\n')
        .map(line => line.trim())
        .filter(line => line.length > 0);

      let header = "";
      // Look for header info that starts with "Project".
      if (lines.length >= 3 && lines[0].startsWith("Project")) {
        header = lines[0] + " " + lines[1] + " " + lines[2];
        if (lines[3] && lines[3].includes("Device Barcode Label")) {
          lines = lines.slice(4);
        } else {
          lines = lines.slice(3);
        }
      }
      // Otherwise, if first line contains unwanted header info.
      else if (lines.length > 0 && lines[0].includes("Version :") && lines[0].includes("Device Barcode Label")) {
        header = lines[0];
        lines.shift();
      }

      // Regular expression to match a serial number (e.g., "001:002:0001").
      const serialRegex = /^\d{3}:\d{3}:\d{4}$/;
      let rawDevices = [];
      let currentDevice = [];

      // Group lines into devices; when a serial number is detected, finalize the device record.
      for (const line of lines) {
        if (serialRegex.test(line)) {
          currentDevice.push(line);
          rawDevices.push(currentDevice.join(" "));
          currentDevice = [];
        } else {
          currentDevice.push(line);
        }
      }
      if (currentDevice.length > 0) {
        rawDevices.push(currentDevice.join(" "));
      }

      // Remove unwanted header text from the first device record if it begins with "Version :".
      if (rawDevices.length > 0 && rawDevices[0].startsWith("Version :")) {
        const headerKey = "Device Type LRM SLC System Address";
        const idx = rawDevices[0].indexOf(headerKey);
        if (idx !== -1) {
          rawDevices[0] = rawDevices[0].substring(idx + headerKey.length).trim();
        }
      }

      // Map raw devices to device objects with an unchecked state.
      const devices = rawDevices.map(txt => ({ text: txt, checked: false }));

      return { header, devices };
    }

    /**
     * Display header information in the designated element.
     * @param {string} header - Header text to display
     */
    function displayHeader(header) {
      document.getElementById("headerInfo").textContent = header;
    }

    /**
     * Render the device checklist and update the device count.
     * This function applies the search filter if any text is in the search bar.
     * @param {Array} devices - Array of device objects
     */
    function displayDevices(devices) {
      // Get the current search term from the search input
      const searchTerm = document.getElementById("searchDevices").value.toLowerCase();

      // Filter devices based on the search term
      const filteredDevices = devices
        .map((device, index) => ({ device, index }))
        .filter(item => {
          return (!searchTerm ||
                  item.device.text.toLowerCase().includes(searchTerm));
        });

      const deviceList = document.getElementById("deviceList");
      deviceList.innerHTML = ""; // Clear previous list

      // Update device count display to show filtered devices
      document.getElementById("deviceCount").textContent =
        "Device Count: " + filteredDevices.length;

      // Iterate over filtered devices and render each
      filteredDevices.forEach((item, displayIndex) => {
        const device = item.device;
        const index = item.index;
        
        // Optional: Countdown from the total number of filtered devices
        let orderHTML = "";
        if (counterEnabled) {
          const countdown = filteredDevices.length - displayIndex;
          orderHTML = `<span class="orderCounter">${countdown}</span>`;
        }

        const li = document.createElement("li");
        li.setAttribute("role", "listitem");

        const isChecked = device.checked ? "checked" : "";
        // Apply line-through style if crossout is enabled and the device is checked
        const textStyle = (crossoutEnabled && device.checked)
          ? "text-decoration: line-through;"
          : "";

        li.innerHTML =
          `${orderHTML}
           <input type="checkbox" id="device-${index}" ${isChecked} aria-label="Check device: ${device.text}">
           <label for="device-${index}" style="${textStyle}">${device.text}</label>`;

        // Handle checkbox changes (using the original device index)
        li.querySelector("input[type='checkbox']").addEventListener("change", function(e) {
          if (accidentalTouchEnabled) {
            // If "accidental touch" is on, don't allow unchecking a previously checked device
            if (deviceChecklistData.devices[index].checked && !e.target.checked) {
              e.target.checked = true;
            } else {
              deviceChecklistData.devices[index].checked = e.target.checked;
            }
          } else {
            deviceChecklistData.devices[index].checked = e.target.checked;
          }
          saveSession();
          // Re-render the list to reflect any crossout or countdown changes
          displayDevices(deviceChecklistData.devices);
        });

        deviceList.appendChild(li);
      });

      // Show or hide controls based on whether there are any devices loaded
      document.getElementById("controls").style.display = (devices.length > 0) ? "block" : "none";
    }

    /**
     * EXPORT - Let the user download the entire checklist as a JSON file.
     */
    function exportListToFile() {
      // Convert data to a JSON string; pretty-print with 2 spaces for readability
      const dataStr = JSON.stringify(deviceChecklistData, null, 2);

      // Create a Blob from the JSON
      const blob = new Blob([dataStr], { type: 'application/json' });

      // Create a temporary <a> link and use URL.createObjectURL to download the file
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = 'device-checklist.json'; // The file name
      link.click();

      // Clean up the URL object
      URL.revokeObjectURL(url);
    }

    /**
     * IMPORT - Load a .json checklist file that the user has.
     */
    function importListFromFile(event) {
      const file = event.target.files[0];
      if (!file) return; // user canceled or didn't choose a file

      if (!file.name.toLowerCase().endsWith('.json')) {
        alert("Please select a .json file.");
        return;
      }

      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const importedData = JSON.parse(e.target.result);
          // Overwrite current data
          deviceChecklistData = importedData;

          // Save & re-render
          saveSession();
          displayHeader(deviceChecklistData.header);
          displayDevices(deviceChecklistData.devices);
          alert("Successfully imported the checklist from file!");
        } catch (err) {
          alert("Invalid JSON file. Could not import.");
        }
      };
      reader.readAsText(file);
    }

    /**
     * Helper function: reads and parses a single PDF file, returning { header, devices }.
     */
    function parsePDF(file) {
      return new Promise((resolve, reject) => {
        const fileReader = new FileReader();
        fileReader.onload = function() {
          const typedarray = new Uint8Array(this.result);
          pdfjsLib.getDocument(typedarray).promise
            .then(pdf => {
              const pagesPromises = [];
              for (let i = 1; i <= pdf.numPages; i++) {
                pagesPromises.push(pdf.getPage(i).then(page => page.getTextContent()));
              }
              Promise.all(pagesPromises).then(pages => {
                let fullText = "";
                pages.forEach(page => {
                  page.items.forEach(item => {
                    fullText += item.str + "\n";
                  });
                });
                resolve(extractHeaderAndDevices(fullText));
              }).catch(err => reject(err));
            })
            .catch(error => reject(error));
        };
        fileReader.readAsArrayBuffer(file);
      });
    }

    /**
     * Helper function to parse an Excel file.
     * It reads rows starting at row 7, columns B through G, and creates device objects.
     * @param {File} file - The Excel file uploaded by the user.
     * @returns {Promise} - Resolves with an object { header, devices }
     */
    function parseExcel(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = function(e) {
          const data = new Uint8Array(e.target.result);
          const workbook = XLSX.read(data, { type: 'array' });
          // Use the first worksheet.
          const firstSheetName = workbook.SheetNames[0];
          const worksheet = workbook.Sheets[firstSheetName];
          const devices = [];
          let row = 7; // devices start at row 7.
          while (true) {
            // Check if cell B(row) has a value.
            const cellB = worksheet["B" + row];
            if (!cellB || cellB.v === undefined || cellB.v === null || cellB.v === "") {
              break;
            }
            let deviceText = "";
            // Concatenate cells from columns B through G (with a space separator).
            ["B", "C", "D", "E", "F", "G"].forEach(col => {
              const cell = worksheet[col + row];
              if (cell && cell.v) {
                deviceText += cell.v + " ";
              }
            });
            devices.push({ text: deviceText.trim(), checked: false });
            row++;
          }
          // For Excel files, header remains empty (or you could extract one if needed).
          resolve({ header: "", devices });
        };
        reader.onerror = reject;
        reader.readAsArrayBuffer(file);
      });
    }

    // Mark all devices as completed.
    document.getElementById("markAllBtn").addEventListener("click", function() {
      deviceChecklistData.devices.forEach(device => device.checked = true);
      saveSession();
      displayDevices(deviceChecklistData.devices);
    });

    // Clear all checkbox selections.
    document.getElementById("clearAllBtn").addEventListener("click", function() {
      deviceChecklistData.devices.forEach(device => device.checked = false);
      saveSession();
      displayDevices(deviceChecklistData.devices);
    });

    // Button to clear the saved session (with confirmation).
    document.getElementById("clearSessionBtn").addEventListener("click", function() {
      if (confirm("Are you sure you want to clear the saved session? This will remove the current checklist.")) {
        clearSession();
        displayHeader("");
        displayDevices([]);
      }
    });

    // Toggle the crossout effect.
    document.getElementById("toggleCrossout").addEventListener("change", function(e) {
      crossoutEnabled = e.target.checked;
      displayDevices(deviceChecklistData.devices);
    });

    // Toggle the simple countdown display.
    document.getElementById("toggleCounter").addEventListener("change", function(e) {
      counterEnabled = e.target.checked;
      displayDevices(deviceChecklistData.devices);
    });

    // Toggle the accidental touch feature.
    document.getElementById("toggleAccidentalTouch").addEventListener("change", function(e) {
      accidentalTouchEnabled = e.target.checked;
      displayDevices(deviceChecklistData.devices);
    });

    // Listen for typing in the Search box & update in real-time
    document.getElementById("searchDevices").addEventListener("input", function() {
      displayDevices(deviceChecklistData.devices);
    });

    // On page load, check for an existing session and load it.
    window.addEventListener("load", function() {
      if (loadSession()) {
        displayHeader(deviceChecklistData.header);
        displayDevices(deviceChecklistData.devices);
      }
    });

    // Register Service Worker for PWA capabilities.
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', function() {
        navigator.serviceWorker.register('service-worker.js')
          .then(function(registration) {
            console.log('ServiceWorker registration successful with scope: ', registration.scope);
          })
          .catch(function(error) {
            console.log('ServiceWorker registration failed:', error);
          });
      });
    }

    // Attach event listeners to Export/Import file buttons
    document.getElementById('exportFileBtn').addEventListener('click', exportListToFile);

    // We'll add a hidden <input type="file"> for the import flow, triggered by the button
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = '.json';
    fileInput.style.display = 'none';
    fileInput.addEventListener('change', importListFromFile);
    document.body.appendChild(fileInput);

    document.getElementById('importFileBtn').addEventListener('click', () => {
      fileInput.value = ''; // reset so user can pick a file each time
      fileInput.click();
    });

    // Process one or more PDF uploads, extract devices, and update the session.
    document.getElementById("pdfInput").addEventListener("change", function(e) {
      const files = e.target.files;
      if (!files || files.length === 0) {
        alert("Please upload at least one valid PDF file.");
        return;
      }
      
      const loadingIndicator = document.getElementById("loading");
      loadingIndicator.textContent = "Loading PDF(s), please wait...";

      // Build a list of promises to parse each selected PDF.
      const parsePromises = [];
      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        // Skip any non-PDF files if user selects them by mistake.
        if (file.type === "application/pdf") {
          parsePromises.push(parsePDF(file));
        }
      }

      // When all PDFs are done parsing:
      Promise.all(parsePromises)
        .then(results => {
          // results is an array of { header, devices } from each PDF.
          results.forEach(extracted => {
            // If there's no header set yet, use the first PDF's header.
            if (!deviceChecklistData.header && extracted.header) {
              deviceChecklistData.header = extracted.header;
            }
            // Append new devices to the existing list.
            if (extracted.devices && extracted.devices.length) {
              deviceChecklistData.devices.push(...extracted.devices);
            }
          });

          saveSession();
          displayHeader(deviceChecklistData.header);
          displayDevices(deviceChecklistData.devices);
          loadingIndicator.textContent = "";
        })
        .catch(error => {
          console.error("Error loading PDFs: ", error);
          loadingIndicator.textContent = "Error loading one or more PDFs.";
        });
    });

    // Process Excel file uploads, extract devices, and update the session.
    document.getElementById("excelInput").addEventListener("change", function(e) {
      const files = e.target.files;
      if (!files || files.length === 0) {
        alert("Please upload at least one valid Excel file.");
        return;
      }
      
      const loadingIndicator = document.getElementById("loading");
      loadingIndicator.textContent = "Loading Excel file(s), please wait...";

      const parsePromises = [];
      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        // Check file extension as an extra precaution.
        if (file.name.endsWith(".xlsx") || file.name.endsWith(".xls")) {
          parsePromises.push(parseExcel(file));
        }
      }

      Promise.all(parsePromises)
        .then(results => {
          results.forEach(extracted => {
            if (!deviceChecklistData.header && extracted.header) {
              deviceChecklistData.header = extracted.header;
            }
            if (extracted.devices && extracted.devices.length) {
              deviceChecklistData.devices.push(...extracted.devices);
            }
          });
          saveSession();
          displayHeader(deviceChecklistData.header);
          displayDevices(deviceChecklistData.devices);
          loadingIndicator.textContent = "";
        })
        .catch(error => {
          console.error("Error loading Excel files: ", error);
          loadingIndicator.textContent = "Error loading one or more Excel files.";
        });
    });
  </script>
</body>
</html>
